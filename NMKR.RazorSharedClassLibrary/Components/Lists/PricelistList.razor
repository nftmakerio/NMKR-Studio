@using NMKR.Shared.Functions.Extensions
@using NMKR.Shared.Functions.Metadata
 @inject ISnackbar Snackbar
 @inject NavigationManager NavigationManager
 @inject IConnectionMultiplexer _redis
 @inject IStringLocalizer _loc

<MudTable Elevation="0" Items="pricelist" Class="border" Style="border-color:#E0E0E0 " Hover="true" Bordered="true" Striped="false" HorizontalScrollbar="true" T="Pricelist" Loading="@progressIsVisible">
    <HeaderContent>
        <MudTh Style="text-align:right; max-width: 180px; width:180px;">@_loc["Count NFT/Tokens"]</MudTh>
        <MudTh Style="text-align:right; max-width: 150px; width:150px;">@_loc["Price"]</MudTh>
        <MudTh>@_loc["Breakdown"]</MudTh>
        <MudTh>@_loc["State"]</MudTh>
        <MudTh>@_loc["Active from (UTC)"]</MudTh>
        <MudTh>@_loc["Active to (UTC)"]</MudTh>
        <MudTh>@_loc["Actions"]</MudTh>
    </HeaderContent>

    <RowTemplate>
        <MudTd>
            @context.Countnftortoken
            <MudText Color="Color.Error" Typo="Typo.body2">
                @GetMaxCountErrorMessage(context)
            </MudText>
        </MudTd>
        <MudTd Style="text-align: right">
            <MudText Color="@GetColor(context)">

                @if (context.Priceinlovelace == -1 && (context.Currency != Coin.USD.ToString() && context.Currency != Coin.EUR.ToString() && context.Currency != Coin.JPY.ToString()))
                {
                    <MudText>Any @context.Currency</MudText>
                }
                else 
                {
                    @if (context.Currency == Coin.BTC.ToString())
                    {
                        <small>
                        @(GlobalFunctions.FormatCurrency(context.Priceinlovelace, 8, context.Currency.ToEnum<Coin>()))
                        @(" " + context.Currency)
                        <br />
                        @("(" +context.Priceinlovelace+ " sat)" )
                        </small>
                    }
                    else
                    {
                        @(GlobalFunctions.FormatCurrency(context.Priceinlovelace, 2, context.Currency.ToEnum<Coin>()))
                        @(" " + context.Currency)
                    }
                }
            </MudText>
            <MudText Color="@GetColor(context)" Typo="Typo.body2">
                @GetErrorMessage(context)
            </MudText>

            @if (context.Currency == Coin.USD.ToString() || context.Currency == Coin.EUR.ToString() || context.Currency == Coin.JPY.ToString())
            {
                @if (project != null && project.Enabledcoins.Contains(Coin.ADA.ToString()))
                {
                    <br/>
                    <small>@GlobalFunctions.FormatCurrency(GlobalFunctions.GetPriceInEntities(_redis, context), 2, Coin.ADA) ADA</small>
                }

                @if (project != null && project.Enabledcoins.Contains(Coin.SOL.ToString()))
                {
                    <br />
                    <small>@GlobalFunctions.FormatCurrency(GlobalFunctions.GetPriceinLamport(_redis, context, Coin.SOL), 2,Coin.SOL) SOL</small>
                }

                @if (project != null && project.Enabledcoins.Contains(Coin.APT.ToString()))
                {
                    <br />
                    <small>@GlobalFunctions.FormatCurrency(GlobalFunctions.GetPriceinLamport(_redis, context, Coin.APT), 2,Coin.APT) APT</small>
                }
                @if (project != null && project.Enabledcoins.Contains(Coin.BTC.ToString()))
                {
                    <br />
                    <small>@GlobalFunctions.FormatCurrency(GlobalFunctions.GetPriceinLamport(_redis, context, Coin.BTC), 2,Coin.BTC) BTC</small>
                }
                <br />
            }
            @if (context.Priceintoken != null)
            {
                <small>
                    PLUS: <DisplayComaNumbers Number="@GlobalFunctions.FormatMultiplier(context.Priceintoken ?? 0, context.Tokenmultiplier)"></DisplayComaNumbers>
                    x @GlobalFunctions.GetFtPayTokenname(context.Tokenpolicyid, context.Tokenassetid)
                </small>
            }
        </MudTd>

        <MudTd>
            @if (context.Currency != Coin.SOL.ToString() && context.Currency != Coin.APT.ToString() && context.Currency != Coin.BTC.ToString()  && project != null && project.Enabledcoins.Contains(Coin.ADA.ToString()))
            {
                <ul style="list-style-type: circle;">
                    <li>Deposit back to purchaser: @GetDepositBack(context)</li>
                    @if (project is { Cip68: true })
                    {
                        <li>Reference Token: @GetCip68ReferenceTokenFees(context)</li>
                    }

                    <li>NMKR Fees: @GetNmkrFees(context)</li>
                    <li>Transaction Fees: @GetNetworkFees(context)</li>
                    <li>Additional Wallets: @GetAdditionalPayoutWallets(context, out var m1, out var m2)</li>
                    <li><b>You will receive: @YouReceive(context, out var minvalue)</b></li>
                </ul>

                @if (context.Currency == Coin.USD.ToString() || context.Currency == Coin.EUR.ToString() || context.Currency == Coin.JPY.ToString())
                {
                    <br/>
                    <span>Solana/Aptos/Bitcoin Breakdown is coming soon...</span>
                }

            }
            else
            {
                @switch (context.Currency.ToEnum<Coin>())
                {
                    case Coin.APT:
                        <span>Aptos Breakdown is coming soon...</span>
                        break;
                    case Coin.SOL:
                        <span>Solana Breakdown is coming soon...</span>
                        break;
                    case Coin.BTC:
                        <span>Bitcoin Breakdown is coming soon...</span>
                        break;

                }
            }
        </MudTd>

        <MudTd>
            @switch (context.State)
            {
                case "active":
                    <NMKRChip Color="Color.Success" Size="Size.Small" Variant="Variant.Filled">@_loc["Active"]</NMKRChip>
                    break;
                case "notactive":
                    <NMKRChip Color="Color.Error" Size="Size.Small" Variant="Variant.Filled">@_loc["Not active"]</NMKRChip>
                    break;
            }
        </MudTd>
        <MudTd>
            @(context.Validfrom != null ? ((DateTime)context.Validfrom).ToLongDateString() : "")
        </MudTd>
        <MudTd>
            @(context.Validto != null ? ((DateTime)context.Validto).ToLongDateString() : "")
        </MudTd>

        <MudTd Style="text-align: right">
            <MudNavMenu Class="mud-width-full">
                <MudNavLink @onclick="() => Edit(context.Id)" Icon="@NMKRIcons.Edit">@_loc["Edit"]</MudNavLink>
                <MudNavLink @onclick="() => Delete(context.Id)" Icon="@NMKRIcons.Delete">@_loc["Delete"]</MudNavLink>
            </MudNavMenu>
        </MudTd>
    </RowTemplate>

    <PagerContent>
        <MudTablePager HideRowsPerPage="true" />
    </PagerContent>
</MudTable>
<MudButton DropShadow="false"
Class="mt-5 mb-5 rounded-pill px-6 py-3"
Variant="Variant.Filled"
Color="Color.Tertiary"
StartIcon="@Icons.Material.Filled.AttachMoney"
OnClick="AddPrice">
    @_loc["Create new price"]
</MudButton>

@code {
    [Parameter]
    public int ProjectId { get; set; }
    [Parameter]
    public bool IsAdmin { get; set; }
    [Parameter]
    public EventCallback OnReloadPricelist { get; set; }
    [Inject] private IDialogService DialogService { get; set; }

    private bool progressIsVisible { get; set; } = false;
    private bool isSubmitting;
    // private List<Pricelist> pricelist = new();
    private List<CalculateMetadataSizeClass> _calculateMetadataSizeClasses = new();
    private List<Nftprojectsadditionalpayout> _additionalpayoutswallets = new();
    private List<Pricelist> pricelist = new();
    private Nftproject? project { get; set; }
    private class CalculateMetadataSizeClass
    {
        public long CountNftOrToken { get; init; }
        public long MetadataSize { get; init; }
        public long GotCount { get; init; }
    }

    protected override async Task OnParametersSetAsync()
    {
        await ReloadDataAsync();
    }
    private async Task AddPrice()
    {
        if (isSubmitting)
            return;

        isSubmitting = true;

        Coin coin = Coin.ADA;
        if (project != null && project.Enabledcoins.Contains(Coin.SOL.ToString()))
            coin = Coin.SOL;
        if (project != null && project.Enabledcoins.Contains(Coin.APT.ToString()))
            coin = Coin.APT;
        if (project != null && project.Enabledcoins.Contains(Coin.BTC.ToString()))
            coin = Coin.BTC;
        if (project != null && project.Enabledcoins.Contains(Coin.ADA.ToString()))
            coin = Coin.ADA;
      

        AddPriceClass pl = new(_redis) { Id = null, NftProjectId = ProjectId, Currency = coin.ToString() };

        var parameters = new DialogParameters { { nameof(EditPriceModalWindow.pricelist), pl }, { nameof(EditPriceModalWindow.IsAdminTool), IsAdmin }, { nameof(EditPriceModalWindow.project), project } };
        DialogOptions maxWidth = new() { MaxWidth = MaxWidth.Large, FullWidth = true, BackdropClick = false };
        var dialog = await DialogService.ShowAsync<EditPriceModalWindow>(@_loc["Add price"], parameters, maxWidth);
        var result = await dialog.Result;
        if (result != DialogResult.Cancel())
        {
            await ReloadDataAsync();
            await OnReloadPricelist.InvokeAsync();
        }
        isSubmitting = false;
    }
    private async Task Delete(int id)
    {
        if (isSubmitting)
            return;

        isSubmitting = true;
        bool? result = await DialogService.ShowMessageBox(
            _loc["Warning"],
            _loc["Are you sure you want to delete this price?"],
        yesText: _loc["Delete!"], cancelText: _loc["Cancel"]);
        if (result != null)
        {
            await using EasynftprojectsContext db = new(GlobalFunctions.optionsBuilder.Options);

            var p = await (from a in db.Pricelists
                           where a.Id == id && a.NftprojectId == project.Id
                           select a).FirstOrDefaultAsync();
            if (p != null)
            {
                db.Pricelists.Remove(p);
                await db.SaveChangesAsync();
                await ReloadDataAsync();
                Snackbar.Configuration.PositionClass = Defaults.Classes.Position.TopCenter;
                Snackbar.Add(_loc["Price deleted"], Severity.Success);
                await OnReloadPricelist.InvokeAsync();
            }
            else
            {
                Snackbar.Configuration.PositionClass = Defaults.Classes.Position.TopCenter;
                Snackbar.Add(_loc["Internal error - Please contact support"], Severity.Error);
            }
        }
        isSubmitting = false;
        StateHasChanged();
    }

    private async Task Edit(int id)
    {
        if (isSubmitting)
            return;

        isSubmitting = true;
        await using EasynftprojectsContext db = new(GlobalFunctions.optionsBuilder.Options);

        var p = await (from a in db.Pricelists
                       where a.Id == id && a.NftprojectId == project.Id
                       select a).AsNoTracking().FirstOrDefaultAsync();
        if (p != null)
        {
            await ReloadDataAsync();


            double pr = p.Currency.ToEnum<Coin>() switch
            {
                Coin.ADA => ((double) p.Priceinlovelace / 1000000),
                Coin.SOL => ((double) p.Priceinlovelace / 1000000000),
                Coin.APT => ((double)p.Priceinlovelace  / 100000000),
                Coin.BTC => ((double)p.Priceinlovelace),
                _ => ((double) p.Priceinlovelace / 100)
            };

            AddPriceClass pl = new(_redis)
                {
                    Id = p.Id,
                    NftProjectId = ProjectId,
                    Price = p.Priceinlovelace == -1 ? -1 : pr,
                    Activated = p.State == "active",
                    CountNft = p.Countnftortoken,
                    ValidFrom = p.Validfrom,
                    AdditionalTokenCount = p.Priceintoken / (p.Tokenmultiplier ?? 1),
                    AdditionalTokenPolicyId = p.Tokenpolicyid,
                    AdditionalTokenAssetName = p.Tokenassetid,
                    ValidTo = p.Validto,
                    Currency = p.Currency
                };


            var parameters = new DialogParameters { { nameof(EditPriceModalWindow.pricelist), pl }, { nameof(EditPriceModalWindow.IsAdminTool), IsAdmin }, { nameof(EditPriceModalWindow.project), project } };
            DialogOptions maxWidth = new() { MaxWidth = MaxWidth.Large, FullWidth = true, BackdropClick = false };
            var dialog = await DialogService.ShowAsync<EditPriceModalWindow>(_loc["Edit price"], parameters, maxWidth);
            var result = await dialog.Result;

            if (result != DialogResult.Cancel())
            {
                await ReloadDataAsync();
                await OnReloadPricelist.InvokeAsync();
            }
        }
        isSubmitting = false;
        StateHasChanged();
    }

    public async Task ReloadDataAsync()
    {
        await using EasynftprojectsContext db = new(GlobalFunctions.optionsBuilder.Options);

        progressIsVisible = true;
        //  StateHasChanged();
        project = await (from a in db.Nftprojects
            .Include(a => a.Settings)
                         where a.Id == ProjectId
                         select a).AsNoTracking().FirstOrDefaultAsync();

        pricelist = await (from a in db.Pricelists
                           where a.NftprojectId == ProjectId
                           orderby a.Countnftortoken
                           select a).AsNoTracking().ToListAsync();

        _additionalpayoutswallets = await (from a in db.Nftprojectsadditionalpayouts
            .Include(a => a.Wallet)
                                           where a.NftprojectId == ProjectId 
                                           select a).AsNoTracking().ToListAsync();

        progressIsVisible = false;
        StateHasChanged();
    }

    private string GetDepositBack(Pricelist context)
    {
        if (project == null)
            return "";
        long countnft = 1;
        if (project is { Maxsupply: 1 })
            countnft = context.Countnftortoken;

        GlobalFunctions.GetDepositBackInAda(project, countnft, out double minvalue, out double maxvalue);

        if (Math.Abs(minvalue - maxvalue) < 0.01f)
            return $"{minvalue.ToString("F2", CultureInfo.GetCultureInfo("en-US"))} ADA";

        return $"≈ {minvalue.ToString("F2", CultureInfo.GetCultureInfo("en-US"))} - {maxvalue.ToString("F2", CultureInfo.GetCultureInfo("en-US"))} ADA";
    }
    private MinMaxClass GetDepositBackValue(Pricelist context)
    {
        if (project == null)
            return new MinMaxClass(0,0);
        long countnft = 1;
        if (project is { Maxsupply: 1 })
            countnft = context.Countnftortoken;

        GlobalFunctions.GetDepositBackInAda(project, countnft, out double minvalue, out double maxvalue);

        return new MinMaxClass(minvalue, maxvalue);
    }
    private string GetNmkrFees(Pricelist context)
    {
        if (project == null)
            return "";
        long countnft = 1;
        if (project is { Maxsupply: 1 })
            countnft = context.Countnftortoken;
        long ada = context.Priceinlovelace;
        if (context.Currency != Coin.ADA.ToString())
            ada = GlobalFunctions.GetPriceInEntities(_redis, context);
        var value = GlobalFunctions.GetNmkrFeesInAda(project, countnft, ada, out string text);
        return text;
    }
    private MinMaxClass GetNmkrFeesValue(Pricelist context)
    {
        if (project == null)
            return new MinMaxClass(0, 0);
        long countnft = 1;
        if (project is { Maxsupply: 1 })
            countnft = context.Countnftortoken;
        long ada = context.Priceinlovelace;
        if (context.Currency != Coin.ADA.ToString())
            ada = GlobalFunctions.GetPriceInEntities(_redis, context);
        var value = GlobalFunctions.GetNmkrFeesInAda(project, countnft, ada, out string text);
        return new MinMaxClass(value, value);
    }
    private string YouReceive(Pricelist context, out double minValue)
    {
        minValue = 0;
        if (project == null)
            return $"0 ADA";
        if (context.Priceinlovelace == 0)
            return $"0 ADA";

        long countnft = 1;
        if (project is { Maxsupply: 1 })
            countnft = context.Countnftortoken;
        GlobalFunctions.GetDepositBackInAda(project, countnft, out double minvalue, out double maxvalue);
        GlobalFunctions.GetNetworkFeesInAda(countnft, out double minvalue1, out double maxvalue1);

        // When decentral is enabled, the network fees are irrelevant
        if (project.Enabledecentralpayments)
        {
            minvalue1 = 0;
            maxvalue1 = 0;
        }

        long ada = context.Priceinlovelace;
        if (context.Currency != Coin.ADA.ToString())
            ada = GlobalFunctions.GetPriceInEntities(_redis, context);

        var nmkrfees = GlobalFunctions.GetNmkrFeesInAda(project, countnft, ada, out string text);
        GetAdditionalPayoutWallets(context, out double minAddPayoutWallet, out double maxAddPayoutWallet);
        GlobalFunctions.GetCip68ReferenceCostsInAda(project, countnft, out double cip68Referenceminvalue, out double cip68Referencemaxvalue);

        var min1 = ((float)ada / 1000000f) - minvalue - minvalue1 - nmkrfees - minAddPayoutWallet - cip68Referenceminvalue;
        var max1 = ((float)ada / 1000000f) - maxvalue - maxvalue1 - nmkrfees - maxAddPayoutWallet - cip68Referencemaxvalue;

        minValue = min1;
        if (min1 < 0)
            min1 = 0;
        if (max1 < 0)
            max1 = 0;

        return max1 == min1 ? $"≈ {max1.ToString("F2", CultureInfo.GetCultureInfo("en-US"))} ADA" : $"≈ {max1.ToString("F2", CultureInfo.GetCultureInfo("en-US"))} - {min1.ToString("F2", CultureInfo.GetCultureInfo("en-US"))} ADA";
    }

    private string GetNetworkFees(Pricelist context)
    {
        if (project == null)
            return "";
        long countnft = 1;
        if (project is { Maxsupply: 1 })
            countnft = context.Countnftortoken;

        GlobalFunctions.GetNetworkFeesInAda(countnft, out double minvalue, out double maxvalue);

        return $"≈ {minvalue.ToString("F2", CultureInfo.GetCultureInfo("en-US"))} - {maxvalue.ToString("F2", CultureInfo.GetCultureInfo("en-US"))} ADA";
    }
    private MinMaxClass GetNetworkFeesValue(Pricelist context)
    {
        if (project == null)
            return new MinMaxClass(0,0);
        long countnft = 1;
        if (project is { Maxsupply: 1 })
            countnft = context.Countnftortoken;

        GlobalFunctions.GetNetworkFeesInAda(countnft, out double minvalue, out double maxvalue);
        return new MinMaxClass(minvalue, maxvalue);
    }

    private Color GetColor(Pricelist context)
    {
        if (context.Priceinlovelace == -1 || project == null || context.Currency == Coin.SOL.ToString() || context.Currency == Coin.APT.ToString() || context.Currency == Coin.BTC.ToString())
            return Color.Default;

        if (!project.Enabledcoins.Contains(Coin.ADA.ToString()))
            return Color.Default;

        try
        {
            var lovelace = GlobalFunctions.GetPriceInEntities(_redis, context);



            switch (project.Enabledecentralpayments)
            {
                case true when lovelace < 2000000 + project.Settings.Mintingcosts && lovelace != 0:
                case false when lovelace < 3500000 + project.Settings.Mintingcosts && lovelace != 0:
                    return Color.Error;
            }
            if (context.Priceinlovelace == 0) return Color.Default;
            YouReceive(context, out var minvalue);
            if (minvalue < 1)
                return Color.Error;
        }
        catch
        {
            return Color.Default;
        }
        return Color.Default;
    }

    private string GetErrorMessage(Pricelist context)
    {
        if (project == null)
            return "";

        if (context.Priceinlovelace == -1)
            return "";

        if (context.Currency == Coin.SOL.ToString())
            return "";

        if (context.Currency == Coin.APT.ToString())
            return "";
        if (context.Currency == Coin.BTC.ToString())
            return "";

        if (!project.Enabledcoins.Contains(Coin.ADA.ToString()))
            return "";

        try
        {
            var lovelace = GlobalFunctions.GetPriceInEntities(_redis, context);
            if (project.Enabledecentralpayments && lovelace < (2000000+ project.Settings.Mintingcosts) && lovelace != 0)
                return _loc["The price is too low because of minutxo and minting costs. The transactions can not be submitted"];
            if (!project.Enabledecentralpayments && lovelace < (3500000 + project.Settings.Mintingcosts) && lovelace != 0)
                return _loc["The price is propably low because of minutxo and minting costs. You can enable Multisig payments for lower prices"];

            if (context.Priceinlovelace == 0) return "";

            YouReceive(context, out var minvalue);
            if (minvalue < 1)
                return _loc["The price is too low. The minimum amount you need to receive is 1 ADA"];
        }
        catch (Exception e)
        {
            return e.Message;
        }

        return "";
    }

    private string GetMaxCountErrorMessage(Pricelist context)
    {
        var res = Task.Run(async () => await GetMaxCountErrorMessageAsync(context));
        return res.Result;
    }

    private async Task<string> GetMaxCountErrorMessageAsync(Pricelist context)
    {
        if (project == null)
            return "";

        await using EasynftprojectsContext db = new(GlobalFunctions.optionsBuilder.Options);
        if (context.State == "active" && (context.Validfrom == null || context.Validfrom < DateTime.Now) && (context.Validto == null || context.Validto > DateTime.Now))
        {
            var plx = await (from a in db.Pricelists
                             where a.NftprojectId == project.Id && a.Countnftortoken == context.Countnftortoken && a.Id != context.Id && a.State == "active" && a.Currency == context.Currency &&
                                   (a.Validfrom == null || a.Validfrom < DateTime.Now) &&
                                   (a.Validto == null || a.Validto > DateTime.Now)
                             select a).FirstOrDefaultAsync();

            if (plx != null)
                return _loc["An identical number of tokens/nfts is already entered in the price list. This can lead to problems."];
        }
        if (project is { Maxsupply: > 1 })
            return "";

        // return "";
        var t = _calculateMetadataSizeClasses.Find(x => x.CountNftOrToken == context.Countnftortoken);
        if (t == null)
        {
            var nfts = db.Nfts.FromSqlRaw($"Call SearchNfts('{ProjectId}','all','','0','{(int)context.Countnftortoken}','id')").ToList();
            var mdc = new GetMetadataClass((from a in nfts select new NftIdWithMintingAddressClass(a.Id,"")).ToArray(), true, db);
            var md = await mdc.MetadataResultAsync();
            long size = 0;
            if (!string.IsNullOrEmpty(md.Metadata))
            {
                size = JsonConvert.SerializeObject(JsonConvert.DeserializeObject(md.Metadata), Formatting.None).Length;
            }
            t = new CalculateMetadataSizeClass() { CountNftOrToken = context.Countnftortoken, MetadataSize = size, GotCount = nfts.Count };
            _calculateMetadataSizeClasses.Add(t);
        }

        if ((context.Currency == Coin.ADA.ToString() || context.Currency == Coin.USD.ToString() || context.Currency == Coin.EUR.ToString() || context.Currency == Coin.JPY.ToString())  && project.Enabledcoins.Contains(Coin.ADA.ToString()))
        {
            if (t.GotCount != context.Countnftortoken)
                return _loc["There are too few NFTs in the project. The approximate size of the metadata cannot be calculated."];

            if (t.MetadataSize >= 15000)
                return _loc["The number of NFTs will probably be too high, as the metadata size may exceed the 16Kb limit."];
        }
        if ((context.Currency == Coin.SOL.ToString() || context.Currency == Coin.USD.ToString() || context.Currency == Coin.EUR.ToString() || context.Currency == Coin.JPY.ToString()) && project.Enabledcoins.Contains(Coin.SOL.ToString()))
        {
            if (context.Countnftortoken >= 10)
                return _loc["The number of NFTs will probably be too high, because of limitations of the Solana blockchain"];
        }
        if ((context.Currency == Coin.APT.ToString() || context.Currency == Coin.USD.ToString() || context.Currency == Coin.EUR.ToString() || context.Currency == Coin.JPY.ToString()) && project.Enabledcoins.Contains(Coin.APT.ToString()))
        {
            if (context.Countnftortoken >= 10)
                return _loc["The number of NFTs will probably be too high, because of limitations of the Aptos blockchain"];
        }
        if ((context.Currency == Coin.BTC.ToString() || context.Currency == Coin.USD.ToString() || context.Currency == Coin.EUR.ToString() || context.Currency == Coin.JPY.ToString()) && project.Enabledcoins.Contains(Coin.BTC.ToString()))
        {
            if (context.Countnftortoken >= 10)
                return _loc["The number of NFTs will probably be too high, because of limitations of the Bitcoin blockchain"];
        }
        return "";
    }

    private string GetAdditionalPayoutWallets(Pricelist context, out double minvalue, out double maxvalue)
    {
        minvalue = 0;
        maxvalue = 0;
        if (project == null)
            return "";
        long ada = context.Priceinlovelace;
        if (context.Currency != Coin.ADA.ToString())
            ada = GlobalFunctions.GetPriceInEntities(_redis, context);

        var deposit = GetDepositBackValue(context);
        var reftoken = GetCip68ReferenceTokenFeesValue(context);
        var nmkrfees = GetNmkrFeesValue(context);
        var fees = GetNetworkFeesValue(context);

        var addvaluemin = GetAdditionalPayoutWalletsAmount(context, ada - deposit.MinValueCardanoLovelace-reftoken.MinValueCardanoLovelace-nmkrfees.MinValueCardanoLovelace-fees.MinValueCardanoLovelace);
        var addvaluemax = GetAdditionalPayoutWalletsAmount(context, ada - deposit.MaxValueCardanoLovelace-reftoken.MaxValueCardanoLovelace-nmkrfees.MaxValueCardanoLovelace-fees.MaxValueCardanoLovelace);

        minvalue = addvaluemin;
        maxvalue = addvaluemax;

        return $"≈ {addvaluemin.ToString("F2", CultureInfo.GetCultureInfo("en-US"))} - {addvaluemax.ToString("F2", CultureInfo.GetCultureInfo("en-US"))} ADA";
    }

    private double GetAdditionalPayoutWalletsAmount(Pricelist context, long price)
    {
        long addvalue = 0;
        foreach (var nftprojectsadditionalpayout in _additionalpayoutswallets.OrEmptyIfNull())
        {
            if (context.Currency == Coin.ADA.ToString() && nftprojectsadditionalpayout.Coin != context.Currency)
                continue;
            if (context.Currency == Coin.SOL.ToString() && nftprojectsadditionalpayout.Coin != context.Currency)
                continue;
            if (context.Currency == Coin.APT.ToString() && nftprojectsadditionalpayout.Coin != context.Currency)
                continue;
            if (context.Currency == Coin.BTC.ToString() && nftprojectsadditionalpayout.Coin != context.Currency)
                continue;
            long countnft = 1;
            if (project is { Maxsupply: 1 })
                countnft = context.Countnftortoken;
            addvalue += ConsoleCommand.GetAdditionalPayoutwalletsValue(nftprojectsadditionalpayout, price, countnft);
        }

        return (double)(addvalue / 1000000f);
    }

    private string GetCip68ReferenceTokenFees(Pricelist context)
    {
        if (project == null)
            return "";

        if (project is { Cip68: false })
            return "0.00 ADA";

        GlobalFunctions.GetCip68ReferenceCostsInAda(project, context.Countnftortoken, out double minvalue, out double maxvalue);

        if (Math.Abs(minvalue - maxvalue) < 0.01f)
            return $"{minvalue.ToString("F2", CultureInfo.GetCultureInfo("en-US"))} ADA";

        return $"≈ {minvalue.ToString("F2", CultureInfo.GetCultureInfo("en-US"))} - {maxvalue.ToString("F2", CultureInfo.GetCultureInfo("en-US"))} ADA";
    }
    private MinMaxClass GetCip68ReferenceTokenFeesValue(Pricelist context)
    {
        if (project == null)
            return new MinMaxClass(0, 0);

        if (project is { Cip68: false })
            return new MinMaxClass(0, 0);

        GlobalFunctions.GetCip68ReferenceCostsInAda(project, context.Countnftortoken, out double minvalue, out double maxvalue);

        return new MinMaxClass(minvalue, maxvalue);
    }
}
