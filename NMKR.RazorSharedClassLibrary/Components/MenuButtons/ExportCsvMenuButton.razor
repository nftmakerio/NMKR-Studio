@using BlazorDownloadFile
 @inject ISnackbar Snackbar
 @inject IConnectionMultiplexer _redis;
 @inject IBlazorDownloadFileService BlazorDownloadFileService
<MudOverlay Visible="isSubmitting" DarkBackground="true" Absolute="false" ZIndex="9999">
    <MudProgressCircular Indeterminate="true" />
</MudOverlay>
<MudNavLink @onclick="(() => ExportCsv(NftProjectid))">Export Token Info as CSV</MudNavLink>

@code {
    [Parameter] public int NftProjectid { get; set; }
    [Parameter] public bool IsAdmin { get; set; }
    
    private bool isSubmitting = false;
    [Inject] private IDialogService DialogService { get; set; }

    private async Task ExportCsv(int id)
    {
        if (isSubmitting)
            return;

        isSubmitting = true;
        StateHasChanged();

        await using var db = new EasynftprojectsContext(GlobalFunctions.optionsBuilder.Options);

        var project = await (from a in db.Nftprojects
                             where a.Id == id
                             select a).AsNoTracking().FirstOrDefaultAsync();

        if (project == null)
        {
            isSubmitting = false;
            return;
        }

        var nft = await (from a in db.Nfts
                         where a.NftprojectId == id && (a.State != "deleted") &&
                               a.MainnftId == null && a.Isroyaltytoken == false
                                   select a).AsNoTracking().ToListAsync();


        List<ExportNftCsvClass> nft1 = new();
        foreach (var a in nft)
        {
            nft1.Add(new ExportNftCsvClass
            {
                IpfsHash = a.Ipfshash,
                Tokenname = (project.Tokennameprefix ?? "") + a.Name,
                IagonId= a.Iagonid,
                Displayname = a.Displayname,
                Detaildata = a.Detaildata,
                State = a.State,
                Minted = a.Minted,
                AssetId = a.Assetid,
                Assetname = a.Assetname,
                PolicyId = a.Policyid,
                Id = a.Id,
                Uid = a.Uid,
                Fingerprint = GetFingerPrint(a, project),
                SpecificPaymentGatewayLink = GeneralConfigurationClass.Paywindowlink + "p=" + project.Uid.Replace("-", "") + "&n=" + a.Uid.Replace("-", "") + "&tc=1"
            });
        }

        var path = GeneralConfigurationClass.TempFilePath;
        string filteredfilename = GlobalFunctions.FilterTokenname(project.Projectname);
        string filename = path + filteredfilename + ".zip";
        string csvfilename = path + filteredfilename + ".csv";
        Directory.CreateDirectory(path);
        GlobalFunctions.DeleteFile(filename);
        GlobalFunctions.DeleteFile(csvfilename);

        GlobalFunctions.DeleteOldFiles(path, 1);

        await using (var writer = new StreamWriter(csvfilename))
        await using (var csv = new CsvWriter(writer, CultureInfo.InvariantCulture))
        {
            await csv.WriteRecordsAsync(nft1);
        }


        using var archive = ZipFile.Open(filename, ZipArchiveMode.Create);
        archive.CreateEntryFromFile(csvfilename, Path.GetFileName(filteredfilename + ".csv"), CompressionLevel.Optimal);
        archive.Dispose();

        byte[] AsBytes = await File.ReadAllBytesAsync(filename);
        String AsBase64String = Convert.ToBase64String(AsBytes);

        await BlazorDownloadFileService.DownloadFile(filteredfilename + ".zip", AsBase64String, "application/octet-stream");
        GlobalFunctions.DeleteFile(csvfilename);

        isSubmitting = false;
    }

    private string GetFingerPrint(Nft nft, Nftproject project)
    {
        return (string.IsNullOrEmpty(nft.Fingerprint) ? Bech32Engine.GetFingerprint(nft.Policyid, ((project.Tokennameprefix??"") + nft.Name).ToHex()) : nft.Fingerprint);
    }

}
